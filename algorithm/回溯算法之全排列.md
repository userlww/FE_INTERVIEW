
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

举一个全排列的例子来解释回溯算法

#### 题目描述

[leecode第46题 全排列](https://leetcode.cn/problems/permutations)
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

```
示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
示例 2：

输入：nums = [0,1]
输出：[[0,1],[1,0]]
示例 3：

输入：nums = [1]
输出：[[1]]

```

#### 解题思路

写一个递归方法，用一个数组来标记当前元素是否已经在排列中出现，代码中path.pop()是关键的回溯步骤。

#### 代码实现

```
var permute = function(nums) {
    const result = [];
    const path = [];

    const len = nums.length;
    const scan = function(used) {
        if(path.length === len) {
            result.push(Array.from(path));
            return;
        }

        for(let i = 0; i < len;i++ ) {
            if(used[i]) continue;
            path.push(nums[i]);
            used[i] = true;
            scan(used);
            path.pop();
            used[i] = false;
        }
    }

    scan([]);
    return result;
};
```
