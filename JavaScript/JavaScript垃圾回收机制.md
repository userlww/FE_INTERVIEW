

目前主流浏览器常见的垃圾回收机制有标记清除和引用计数，标记清除为更多的浏览器所使用。下面分别介绍一下这两种垃圾回收机制

### 标记清除

标记清除的过程是这样的：

 1. 变量进入上下文，也可理解为作用域，会加上标记，证明其存在于该上下文；
 2. 将所有在上下文中的变量以及上下文中被访问引用的变量标记去掉，表明这些变量活跃有用；
 3. 在此之后再被加上标记的变量标记为准备删除的变量，因为上下文中的变量已经无法访问它们；
 4. 执行内存清理，销毁带标记的所有非活跃值并回收之前被占用的内存；
 
### 引用计数

引用计数的思路是：跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果这个变量被赋予了另一个值，那么这个旧值的引用数就会减一，当它的引用数变为0时，意味着它不能再被访问，将会被回收，举例说明一下
```
  var o = {
    a: {
      b:2
    }
  };
```

在这段代码中。创建了对象a和b。a被分配给变量o，b则作为a的属性被引用，那么它们两个都不能被回收

```
var o2 = o; 
o = 1; 
```     
我们将o的值赋给了一个新的变量o2，此时 这个对象只有一个o2变量的引用了，原始引用o已经没有了
```
var oa = o2.a; 
o2 = "yo";

```

然后我们定义oa引用对象的a属性，那么对象此时有两个引用，一个oa，一个o2，接下来我们用一个字符串给o2赋值，此时原来的值已经没有引用了，但由于它的a属性还有引用，因此不能被回收。

```        
oa = null; 
```
此时a属性的引用也没有了，可以被回收。

最后，引用计数法的限制有一个问题，当出现循环引用时，两个对象之间始终存在引用关系，无法回收。

```
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o
  return "azerty";
}
f();

```
 
