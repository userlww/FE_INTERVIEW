尾调用是函数式编程的一个重要概念，简单来说就是在函数执行的最后一步调用另一个函数，举例说明

```
function x () {
  return y()
}
```
这端代码中，在x函数的最后一步调用了y函数，就是一个尾调用。也有几种类似的情况，但它们不属于尾调用

```
//情况一

function x() {
  let y = g();
  return y;  //函数调用之后还有赋值操作，不属于尾调用
}

//情况二

function x() {
 return y() +1;  //函数调用后还有运算，不属于尾调用
}


// 情况三

function x() {
  y();    //函数调用之后还有一行隐式的return语句，也不属于尾调用
}

```

### 尾调用优化

函数调用会在内存中形成一个调用栈，保存着调用位置和内部变量等信息，在我们的示例中，我们在函数x中调用函数y，也就是说在调用栈中，函数X上面还会有函数Y，当函数Y执行完毕之后出栈，将结果给到函数X，如果函数Y还调用了函数Z，那么调用栈中还会有函数Z。当函数中存在尾调用时，事实上当前函数的内部变量和调用位置等信息其实已经没有用了，所以当前函数其实已经没有必要存在在栈中了，**直接使用被尾调用的函数的调用信息取代当前函数就可以了**，前面加粗的这一句话，其实就是尾调用优化，尾调用优化是由JavaScript引擎完成的，目前只有Safari浏览器支持，


### 尾递归

函数尾调用自身，称为尾递归

举一个递归的写法来说明

```
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5);

```

在上面这个递归函数写法中，最后一行递归执行不是尾调用，因此它也不是尾递归，这样的话也不会适用于尾调用优化，也就是说每一次调用都会在栈中叠加一个本身函数的调用信息。如果调用n次，则需要保存n个调用记录，如果改造成尾递归，则只会保存一个函数的调用信息

```
  function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120

```
再举一个例子，斐波那契数列

```
function Fibonacci (n) {
  if ( n <= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 超时
Fibonacci(500) // 超时

```

改写为尾递归之后

```
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity

```
由此可见，尾调用优化能对递归调用起到很大的优化作用。


### 总结

- 尾调用指的是在函数最后一步操作调用其他函数，尾调用优化指的是在遇到尾调用时，将外层函数从调用栈中清除，将调用信息移交给被尾调用的函数
- 尾递归指的是在递归函数的最后一步调用自身，能够优化递归函数的执行过程，

### 参考文献

- 《ES6标准入门》- 阮一峰
