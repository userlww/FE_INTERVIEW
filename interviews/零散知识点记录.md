#### commonJS和ES Module的区别

1. 语法不同，commonJS是require和module.exports,ESM 是import导入，export导出
2. commonJS是运行时加载模块，ESM是静态编译期间就会确定依赖
3. ESM会在编译时将所有import提升到顶部，commonJS则不会提升require
4. commonJS导出的是一个值的拷贝，导出之后修改模块内部的值不会影响引用的地方，引用的地方修改也不会影响原模块

#### webpack loader和plugin

- loader用于对模块源码的转换，loader描述了webpack如何处理非JavaScript模块，并且在build中引入这些依赖，loader可以将文件从不同的语言转换为JavaScript。
- Plugin：目的在于解决loader无法实现的其他事，比如对代码的打包优化和压缩，到重新定义环境变量，插件可以用来处理各种各样的任务。

总结一下，loader可以理解为webpack的横向广度，借助loader，webpack可以打包处理各种扩展语言。而plugin可以理解为webpack的纵向深度，在生命周期内注入不同的插件来扩展更多的能力。

#### js的堆内存和栈内存

JavaScript中的基本数据一共有6种：String、Number、Boolean、Null、undefined、Symbol

基本数据类型存储在栈内存中，因为基本数据类型占用空间较小、大小固定，按值访问，属于频繁使用的数据

需要注意的是，闭包中的基本数据类型的变量不是在栈内存中，而是在堆内存中

引用数据类型如对象、数组、方法等存储在堆内存中，因为引用数据类型大小不确定，经常需要占用很大的空间，引用数据类型会在栈内存中存储指针，指向堆中实体的起始地址，寻找引用值时，会首先检索他在栈中的地址，取的地址之后从堆中获取到实体。

#### 为什么js执行会阻塞渲染，而css不会

因为在JavaScript加载之前，浏览器不知道JavaScript要干什么，如果在渲染DOM时脚本中有对DOM节点进行操作的话，会出现不可预期的结果，导致渲染混乱，因此设置GUI渲染和JavaScript线程互斥，避免这种情况发生。

dom解析和css解析是两个并行的线程，所以css加载不会阻塞dom的解析
但是render tree是依赖dom tree和cssom tree的，因此，css的加载会阻塞dom的渲染

#### JavaScript数字精度问题？

在JavaScript中，0.1+0.2并不等于0.3，原因是JavaScript中Number类型时使用的IEEE754规范中的64为双精度浮点数编码，也就是说小数和整数都是被当做浮点数进行存储的，在做运算的时候会将用科学计数法表示的二进制的小数进行计算，二进制计算结束之后再转成10进制，导致出现了上面说的精度问题，常见的解决策略是将小数转为字符串处理或者乘以一个基数计算完之后再除回去。
